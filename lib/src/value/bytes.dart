/*
 * Package : Cbor
 * Author : S. Hamblett <steve.hamblett@linux.com>
 * Date   : 04/01/2022
 * Copyright :  S.Hamblett
 */

import 'dart:convert';
import 'dart:typed_data';

import 'package:cbor/cbor.dart';
import 'package:collection/collection.dart';
import 'package:hex/hex.dart';

import '../constants.dart';
import '../encoder/sink.dart';
import '../utils/arg.dart';
import 'internal.dart';

/// A CBOR byte array.
abstract class CborBytes extends CborValue {
  List<int> get bytes;

  List<List<int>> get bytesList;

  CborLengthType get type;

  factory CborBytes(List<int> bytes, {List<int> tags}) = CborBytesImpl;

  factory CborBytes.indefinite(List<List<int>> bytes, {List<int> tags}) =
      _CborBytesIndefiniteLengthImpl;
}

class CborBytesImpl with CborValueMixin implements CborBytes {
  @override
  final List<int> bytes;
  @override
  final List<int> tags;
  @override
  final CborLengthType type = CborLengthType.definite;

  @override
  List<List<int>> get bytesList => [bytes];

  @override
  int get hashCode => Object.hashAll([bytes, tags].flattened);

  const CborBytesImpl(this.bytes, {this.tags = const []});

  @override
  String toString() => bytes.toString();

  @override
  bool operator ==(Object other) =>
      other is CborBytes &&
      tags.equals(other.tags) &&
      bytes.equals(other.bytes);

  @override
  Object? toObjectInternal(Set<Object> cyclicCheck, ToObjectOptions o) {
    return bytes;
  }

  @override
  Object? toJsonInternal(Set<Object> cyclicCheck, ToJsonOptions o) {
    switch (expectedConversion ?? o.encoding) {
      case JsonBytesEncoding.base16:
        return const HexEncoder(upperCase: true).convert(bytes);
      case JsonBytesEncoding.base64:
        return base64.encode(bytes);
      case JsonBytesEncoding.base64Url:
        return base64Url.encode(bytes).replaceAll('=', '');
    }
  }

  @override
  void encode(EncodeSink sink) {
    CborEncodeDefiniteLengthBytes(this).encode(sink);
  }
}

class _CborBytesIndefiniteLengthImpl with CborValueMixin implements CborBytes {
  @override
  final List<int> tags;
  @override
  final CborLengthType type = CborLengthType.indefinite;
  @override
  final List<List<int>> bytesList;

  @override
  List<int> get bytes => bytesList.flattened.toList(growable: false);

  @override
  int get hashCode => Object.hashAll([bytesList, tags].flattened);

  const _CborBytesIndefiniteLengthImpl(this.bytesList, {this.tags = const []});

  @override
  String toString() => bytes.toString();

  @override
  bool operator ==(Object other) =>
      other is _CborBytesIndefiniteLengthImpl &&
      tags.equals(other.tags) &&
      DeepCollectionEquality().equals(bytesList, other.bytesList);

  @override
  Object? toObjectInternal(Set<Object> cyclicCheck, ToObjectOptions o) {
    return bytes;
  }

  @override
  Object? toJsonInternal(Set<Object> cyclicCheck, ToJsonOptions o) {
    switch (expectedConversion ?? o.encoding) {
      case JsonBytesEncoding.base16:
        return const HexEncoder(upperCase: true).convert(bytes);
      case JsonBytesEncoding.base64:
        return base64.encode(bytes);
      case JsonBytesEncoding.base64Url:
        return base64Url.encode(bytes).replaceAll('=', '');
    }
  }

  @override
  void encode(EncodeSink sink) {
    CborEncodeIndefiniteLengthBytes(bytesList).encode(sink);
  }
}

/// Use this to force the [CborEncoder] to encode an indefinite length byte string.
///
/// This is never generated by decoder.
abstract class CborEncodeIndefiniteLengthBytes extends CborValue {
  factory CborEncodeIndefiniteLengthBytes(
    List<List<int>> items, {
    List<int> tags,
  }) = _CborEncodeIndefiniteLengthBytesImpl;
}

class _CborEncodeIndefiniteLengthBytesImpl
    with CborValueMixin
    implements CborEncodeIndefiniteLengthBytes {
  final List<List<int>> items;
  @override
  final List<int> tags;

  const _CborEncodeIndefiniteLengthBytesImpl(
    this.items, {
    this.tags = const [],
  });

  @override
  Object? toObjectInternal(Set<Object> cyclicCheck, ToObjectOptions o) {
    return CborBytes(
      items.flattened.toList(),
      tags: tags,
    ).toObjectInternal(cyclicCheck, o);
  }

  @override
  Object? toJsonInternal(Set<Object> cyclicCheck, ToJsonOptions o) {
    return CborBytes(
      items.flattened.toList(),
      tags: tags,
    ).toJsonInternal(cyclicCheck, o);
  }

  @override
  void encode(EncodeSink sink) {
    sink.addTags(tags);

    sink.addHeaderInfo(CborConstants.two, Arg.indefiniteLength);

    for (final value in items) {
      CborEncodeDefiniteLengthBytes(CborBytes(value)).encode(sink);
    }

    (const Break()).encode(sink);
  }
}

/// Use this to force the [CborEncoder] to encode an definite length byte string.
///
/// This is never generated by decoder.
abstract class CborEncodeDefiniteLengthBytes extends CborValue {
  factory CborEncodeDefiniteLengthBytes(CborBytes input) =
      _CborEncodeDefiniteLengthBytesImpl;
}

class _CborEncodeDefiniteLengthBytesImpl
    with CborValueMixin
    implements CborEncodeDefiniteLengthBytes {
  final CborBytes inner;

  @override
  List<int> get tags => inner.tags;

  const _CborEncodeDefiniteLengthBytesImpl(this.inner);

  @override
  Object? toObjectInternal(Set<Object> cyclicCheck, ToObjectOptions o) {
    return inner.toObjectInternal(cyclicCheck, o);
  }

  @override
  Object? toJsonInternal(Set<Object> cyclicCheck, ToJsonOptions o) {
    return inner.toJsonInternal(cyclicCheck, o);
  }

  @override
  void encode(EncodeSink sink) {
    sink.addTags(tags);

    sink.addHeaderInfo(CborConstants.two, Arg.int(inner.bytes.length));

    sink.add(inner.bytes);
  }
}

/// A CBOR big int.
abstract class CborBigInt extends CborBytes implements CborInt {
  bool get isNegative;

  factory CborBigInt(BigInt value, [List<int>? tags]) {
    final negative = value.isNegative;
    if (value.isNegative) {
      tags ??= [CborTag.negativeBignum];
      value = ~value;
    } else {
      tags ??= [CborTag.positiveBignum];
    }

    final b = Uint8List(
      (value.bitLength + CborConstants.seven) ~/ CborConstants.byteLength,
    );

    for (var i = b.length - 1; i >= 0; i--) {
      b[i] = value.toUnsigned(CborConstants.byteLength).toInt();
      value >>= CborConstants.byteLength;
    }

    return negative
        ? CborBigInt.fromNegativeBytes(b, tags: tags)
        : CborBigInt.fromBytes(b, tags: tags);
  }

  factory CborBigInt.fromBytes(List<int> bytes, {List<int> tags}) =
      _CborBigIntImpl.fromBytes;

  factory CborBigInt.fromNegativeBytes(List<int> bytes, {List<int> tags}) =
      _CborBigIntImpl.fromNegativeBytes;
}

class _CborBigIntImpl extends CborBytesImpl implements CborBigInt {
  @override
  final bool isNegative;

  const _CborBigIntImpl.fromBytes(
    super.bytes, {
    super.tags = const [CborTag.positiveBignum],
  }) : isNegative = false;

  const _CborBigIntImpl.fromNegativeBytes(
    super.bytes, {
    super.tags = const [CborTag.negativeBignum],
  }) : isNegative = true;

  @override
  Object? toObjectInternal(Set<Object> cyclicCheck, ToObjectOptions o) {
    return toBigInt();
  }

  @override
  Object? toJsonInternal(Set<Object> cyclicCheck, ToJsonOptions o) {
    final output = StringBuffer();

    if (isNegative) {
      output.write('~');
    }

    output.write(
      super.toJsonInternal(
        cyclicCheck,
        o.copyWith(encoding: JsonBytesEncoding.base64Url),
      ),
    );
    return output.toString();
  }

  @override
  BigInt toBigInt() {
    var data = BigInt.zero;
    for (final b in bytes) {
      data <<= CborConstants.byteLength;
      data |= BigInt.from(b);
    }

    return isNegative ? ~data : data;
  }

  @override
  int toInt() => toBigInt().toInt();
}
